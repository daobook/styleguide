# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, xinetzone
# This file is distributed under the same license as the Style Guide
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Style Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 01:11+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../google/cpp/exceptions.rst:2
msgid "规则特例"
msgstr ""

#: ../../google/cpp/exceptions.rst:4
msgid "前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例."
msgstr ""

#: ../../google/cpp/exceptions.rst:7
msgid "现有不合规范的代码"
msgstr ""

#: ../../google/cpp/exceptions.rst:9 ../../google/cpp/exceptions.rst:22
msgid "**总述**"
msgstr ""

#: ../../google/cpp/exceptions.rst:11
msgid "对于现有不符合既定编程风格的代码可以网开一面."
msgstr ""

#: ../../google/cpp/exceptions.rst:13 ../../google/cpp/exceptions.rst:26
msgid "**说明**"
msgstr ""

#: ../../google/cpp/exceptions.rst:15
msgid ""
"当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住, "
"*一致性* 也包括原有的一致性."
msgstr ""

#: ../../google/cpp/exceptions.rst:20
msgid "Windows 代码"
msgstr ""

#: ../../google/cpp/exceptions.rst:24
msgid ""
"Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. "
"我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南."
msgstr ""

#: ../../google/cpp/exceptions.rst:28
msgid "如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:"
msgstr ""

#: ../../google/cpp/exceptions.rst:30
msgid "不要使用匈牙利命名法 (比如把整型变量命名成 ``iNum``). 使用 Google 命名约定, 包括对源文件使用 ``.cc`` 扩展名."
msgstr ""

#: ../../google/cpp/exceptions.rst:32
msgid ""
"Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 ``DWORD``, ``HANDLE`` "
"等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 ``const "
"TCHAR *`` 而不是 ``LPCTSTR``."
msgstr ""

#: ../../google/cpp/exceptions.rst:34
msgid ""
"使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, "
"并将所有警告(warnings)当作错误(errors)处理."
msgstr ""

#: ../../google/cpp/exceptions.rst:36
msgid ""
"不要使用 ``#pragma once``; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y "
"注: 如 ``#ifndef SRC_DIR_BAR_H_``, 参考 :ref:`#define 保护 <define-guard>` 一节)."
msgstr ""

#: ../../google/cpp/exceptions.rst:38
msgid ""
"除非万不得已, 不要使用任何非标准的扩展, 如 ``#pragma`` 和 ``__declspec``. 使用 "
"``__declspec(dllimport)`` 和 ``__declspec(dllexport)`` 是允许的, 但必须通过宏来使用, 比如"
" ``DLLIMPORT`` 和 ``DLLEXPORT``, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展."
msgstr ""

#: ../../google/cpp/exceptions.rst:40
msgid "然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:"
msgstr ""

#: ../../google/cpp/exceptions.rst:42
msgid ""
"通常我们 :ref:`禁止使用多重继承 <multiple-inheritance>`, 但在使用 COM 和 ATL/WTL "
"类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承."
msgstr ""

#: ../../google/cpp/exceptions.rst:44
msgid ""
"虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, "
"应定义 ``_ATL_NO_EXCEPTIONS`` 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, "
"可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理)."
msgstr ""

#: ../../google/cpp/exceptions.rst:46
msgid ""
"通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 ``StdAfx.h`` 或 ``precompile.h`` 的文件. "
"为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 ``precompile.cc`` 中), 使用 ``/FI`` "
"编译器选项以自动包含该文件."
msgstr ""

#: ../../google/cpp/exceptions.rst:48
msgid "资源头文件通常命名为 ``resource.h`` 且只包含宏, 这一文件不需要遵守本风格指南."
msgstr ""

