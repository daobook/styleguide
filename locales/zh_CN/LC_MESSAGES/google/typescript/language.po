# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, xinetzone
# This file is distributed under the same license as the Style Guide
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Style Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 01:11+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../google/typescript/language.rst:2
msgid "语言特性"
msgstr ""

#: ../../google/typescript/language.rst:7
msgid "可见性"
msgstr ""

#: ../../google/typescript/language.rst:9
msgid "限制属性、方法以及类型的可见性有助于代码解耦合。因此："
msgstr ""

#: ../../google/typescript/language.rst:11
msgid "应当尽可能限制符号的可见性。"
msgstr ""

#: ../../google/typescript/language.rst:12
msgid "可以将私有方法在同一文件中改写为独立于所有类以外的内部函数，并将私有属性移至单独的内部类中。"
msgstr ""

#: ../../google/typescript/language.rst:13
msgid ""
"在 TypeScript 中，符号默认的可见性即为 ``public`` ，因此，除了在构造函数中声明公开（ ``public`` ）且非只读（ "
"``readonly`` ）的参数属性之外，不要使用 ``public`` 修饰符。"
msgstr ""

#: ../../google/typescript/language.rst:31
msgid "关于可见性，还可参见 :ref:`ts-export-visibility` 一节。"
msgstr ""

#: ../../google/typescript/language.rst:36
msgid "构造函数"
msgstr ""

#: ../../google/typescript/language.rst:38
msgid "调用构造函数时必须使用括号，即使不传递任何参数。"
msgstr ""

#: ../../google/typescript/language.rst:48
msgid ""
"没有必要提供一个空的或者仅仅调用父类构造函数的构造函数。在 ES2015 "
"标准中，如果没有为类显式地提供构造函数，编译器会提供一个默认的构造函数。但是，含有参数属性、访问修饰符或参数装饰器的构造函数即使函数体为空也不能省略。"
msgstr ""

#: ../../google/typescript/language.rst:90
msgid "类成员"
msgstr ""

#: ../../google/typescript/language.rst:95
msgid "``#private`` 语法"
msgstr ""

#: ../../google/typescript/language.rst:97
msgid "不要使用 ``#private`` 私有字段（又称私有标识符）语法声明私有成员。"
msgstr ""

#: ../../google/typescript/language.rst:106
msgid "而应当使用 TypeScript 的访问修饰符。"
msgstr ""

#: ../../google/typescript/language.rst:115
msgid ""
"为什么？因为私有字段语法会导致 TypeScipt 在编译为 JavaScript 时出现体积和性能问题。同时，ES2015 "
"之前的标准都不支持私有字段语法，因此它限制了 TypeScript 最低只能被编译至 "
"ES2015。另外，在进行静态类型和可见性检查时，私有字段语法相比访问修饰符并无明显优势。"
msgstr ""

#: ../../google/typescript/language.rst:120
msgid "使用 ``readonly``"
msgstr ""

#: ../../google/typescript/language.rst:122
msgid "对于不会在构造函数以外进行赋值的属性，应使用 ``readonly`` 修饰符标记。这些属性并不需要具有深层不可变性。"
msgstr ""

#: ../../google/typescript/language.rst:125
msgid "参数属性"
msgstr ""

#: ../../google/typescript/language.rst:127
msgid ""
"不要在构造函数中显式地对类成员进行初始化。应当使用 TypeScript 的 `参数属性 "
"<https://www.typescriptlang.org/docs/handbook/classes.html#parameter-"
"properties>`_ 语法。"
msgstr ""

#: ../../google/typescript/language.rst:147
msgid ""
"如果需要为参数属性添加文档，应使用 JSDoc 的 ``@param`` 标签，参见 :ref:`ts-parameter-property-"
"comments` 一节。"
msgstr ""

#: ../../google/typescript/language.rst:150
msgid "字段初始化"
msgstr ""

#: ../../google/typescript/language.rst:152
msgid "如果某个成员并非参数属性，应当在声明时就对其进行初始化，这样有时可以完全省略掉构造函数。"
msgstr ""

#: ../../google/typescript/language.rst:174
msgid "用于类的词法范围之外的属性"
msgstr ""

#: ../../google/typescript/language.rst:176
msgid ""
"如果一个属性被用于它们所在类的词法范围之外，例如用于模板（template）的 AngularJS "
"控制器（controller）属性，则禁止将其设为 ``private`` ，因为显然这些属性是用于外部的。"
msgstr ""

#: ../../google/typescript/language.rst:178
msgid ""
"对于这类属性，应当将其设为 ``public`` ，如果有需要的话也可以使用 ``protected`` 。例如，Angular 和 "
"Polymer 的模板属性应使用 ``public`` ，而 AngularJS 应使用 ``protected`` 。"
msgstr ""

#: ../../google/typescript/language.rst:180
msgid "此外，禁止在 TypeScript 代码中使用 ``obj['foo']`` 语法绕过可见性限制进行访问。"
msgstr ""

#: ../../google/typescript/language.rst:182
#: ../../google/typescript/language.rst:1136
msgid "为什么？"
msgstr ""

#: ../../google/typescript/language.rst:184
msgid ""
"如果一个属性被设为 ``private``\\ "
"，就相当于向自动化工具和读者声明对这个属性的访问局限于类的内部。例如，用于查找未被使用的代码的工具可能会将一个私有属性标记为未使用，即使在其它文件中有代码设法绕过了可见性限制对其进行访问。"
msgstr ""

#: ../../google/typescript/language.rst:186
msgid ""
"虽然 ``obj['foo']`` 可以绕过 TypeScript "
"编译器对可见性的检查，但是这种访问方法可能会由于调整了构建规则而失效。此外，它也违反了后文中所提到的 :ref:`ts-optimization-"
"compatibility-for-property-access` 规则。"
msgstr ""

#: ../../google/typescript/language.rst:191
msgid "取值器与设值器（存取器）"
msgstr ""

#: ../../google/typescript/language.rst:193
msgid "可以在类中使用存取器，其中取值器方法必须是纯函数（即结果必须是一致稳定的，且不能有副作用）。存取器还可以用于隐藏内部复杂的实现细节。"
msgstr ""

#: ../../google/typescript/language.rst:209
msgid ""
"如果存取器被用于隐藏类内部的某个属性，则被隐藏的属性应当以诸如 ``internal`` 或 ``wrapped`` "
"此类的完整单词作为前缀或后缀。在使用这些私有属性时，应当尽可能地通过存取器进行访问。取值器和设值器二者至少要有一个是非平凡的，也就是说，存取器不能只用于传递属性值，更不能依赖这种存取器对属性进行隐藏。这种情况下，应当直接将属性设为"
" ``public``\\ 。对于只有取值器没有设值器的属性，则应当考虑直接将其设为 ``readonly``\\ 。"
msgstr ""

#: ../../google/typescript/language.rst:241
msgid "原始类型与封装类"
msgstr ""

#: ../../google/typescript/language.rst:243
msgid ""
"在 TypeScript 中，不要实例化原始类型的封装类，例如 ``String`` 、 ``Boolean`` 、 ``Number`` "
"等。封装类有许多不合直觉的行为，例如 ``new Boolean(false)`` 在布尔表达式中会被求值为 ``true``\\ 。"
msgstr ""

#: ../../google/typescript/language.rst:262
msgid "数组构造函数"
msgstr ""

#: ../../google/typescript/language.rst:264
msgid ""
"在 TypeScript 中，禁止使用 ``Array()`` 构造函数（无论是否使用 ``new`` "
"关键字）。它有许多不合直觉又彼此矛盾的行为，例如："
msgstr ""

#: ../../google/typescript/language.rst:272
msgid "应当使用方括号对数组进行初始化，或者使用 ``from`` 构造一个具有确定长度的数组："
msgstr ""

#: ../../google/typescript/language.rst:289
msgid "强制类型转换"
msgstr ""

#: ../../google/typescript/language.rst:291
msgid ""
"在 TypeScript 中，可以使用 ``String()`` 和 ``Boolean()`` 函数（注意不能和 ``new`` "
"一起使用！）、模板字符串和 ``!!`` 运算符进行强制类型转换。"
msgstr ""

#: ../../google/typescript/language.rst:300
msgid "不建议通过字符串连接操作将类型强制转换为 ``string`` ，这会导致加法运算符两侧的运算对象具有不同的类型。"
msgstr ""

#: ../../google/typescript/language.rst:302
msgid ""
"在将其它类型转换为数字时，必须使用 ``Number()`` 函数，并且，在类型转换有可能失败的场合，必须显式地检查其返回值是否为 ``NaN``"
" 。"
msgstr ""

#: ../../google/typescript/language.rst:306
msgid ""
"``Number('')`` 、 ``Number(' ')`` 和 ``Number('\\t')`` 返回 ``0`` 而不是 ``NaN``"
" 。 ``Number('Infinity')`` 和 ``Number('-Infinity')`` 分别返回 ``Infinity`` 和 "
"``-Infinity`` 。这些情况可能需要特殊处理。"
msgstr ""

#: ../../google/typescript/language.rst:314
msgid ""
"禁止使用一元加法运算符 ``+`` "
"将字符串强制转换为数字。用这种方法进行解析有失败的可能，还有可能出现奇怪的边界情况。而且，这样的写法往往成为代码中的坏味道， ``+`` "
"在代码审核中非常容易被忽略掉。"
msgstr ""

#: ../../google/typescript/language.rst:321
msgid ""
"同样地，代码中也禁止使用 ``parseInt`` 或 ``parseFloat`` "
"进行转换，除非用于解析表示非十进制数字的字符串。因为这两个函数都会忽略字符串中的后缀，这有可能在无意间掩盖了一部分原本会发生错误的情形（例如将 "
"``12 dwarves`` 解析成 ``12``\\ ）。"
msgstr ""

#: ../../google/typescript/language.rst:328
msgid "对于需要解析非十进制数字的情况，在调用 ``parseInt`` 进行解析之前必须检查输入是否合法。"
msgstr ""

#: ../../google/typescript/language.rst:337
msgid "应当使用 ``Number()`` 和 ``Math.floor`` 或者 ``Math.trunc`` （如果支持的话）解析整数。"
msgstr ""

#: ../../google/typescript/language.rst:345
msgid ""
"不要在 ``if`` 、 ``for`` 或者 ``while`` 的条件语句中显式地将类型转换为 ``boolean`` "
"，因为这里原本就会执行隐式的类型转换。"
msgstr ""

#: ../../google/typescript/language.rst:361
msgid "最后，在代码中使用显式和隐式的比较均可。"
msgstr ""

#: ../../google/typescript/language.rst:374
msgid "变量"
msgstr ""

#: ../../google/typescript/language.rst:376
msgid ""
"必须使用 ``const`` 或 ``let`` 声明变量。尽可能地使用 ``const`` ，除非这个变量需要被重新赋值。禁止使用 "
"``var`` 。"
msgstr ""

#: ../../google/typescript/language.rst:383
msgid ""
"与大多数其它编程语言类似，使用 ``const`` 和 ``let`` 声明的变量都具有块级作用域。与之相反的是，使用 ``var`` "
"声明的变量在 JavaScript 中具有函数作用域，这会造成许多难以理解的 bug，因此禁止在 TypeScript 中使用 ``var`` 。"
msgstr ""

#: ../../google/typescript/language.rst:390
msgid "最后，变量必须在使用前进行声明。"
msgstr ""

#: ../../google/typescript/language.rst:395
msgid "异常"
msgstr ""

#: ../../google/typescript/language.rst:397
msgid ""
"在实例化异常对象时，必须使用 ``new Error()`` 语法而非调用 ``Error()`` "
"函数。虽然这两种方法都能够创建一个异常实例，但是使用 ``new`` 能够与代码中其它的对象实例化在形式上保持更好的一致性。"
msgstr ""

#: ../../google/typescript/language.rst:410
msgid "对象迭代"
msgstr ""

#: ../../google/typescript/language.rst:412
msgid ""
"对对象使用 ``for (... in ...)`` 语法进行迭代很容易出错，因为它同时包括了对象从原型链中继承得来的属性。因此，禁止使用裸的 "
"``for (... in ...)`` 语句。"
msgstr ""

#: ../../google/typescript/language.rst:421
msgid ""
"在对对象进行迭代时，必须使用 ``if`` 语句对对象的属性进行过滤，或者使用 ``for (... of Object.keys(...))``"
" 。"
msgstr ""

#: ../../google/typescript/language.rst:448
msgid "容器迭代"
msgstr ""

#: ../../google/typescript/language.rst:450
msgid ""
"不要在数组上使用 ``for (... in ...)`` "
"进行迭代。这是一个违反直觉的操作，因为它是对数组的下标而非元素进行迭代（还会将其强制转换为 ``string`` 类型）！"
msgstr ""

#: ../../google/typescript/language.rst:459
msgid "如果要在数组上进行迭代，应当使用 ``for (... of someArr)`` 语句或者传统的 ``for`` 循环语句。"
msgstr ""

#: ../../google/typescript/language.rst:484
msgid ""
"不要使用 ``Array.prototype.forEach`` 、 ``Set.prototype.forEach`` 和 "
"``Map.prototype.forEach`` 。这些方法会使代码难以调试，还会令编译器的某些检查（例如可见性检查）失效。"
msgstr ""

#: ../../google/typescript/language.rst:493
msgid "为什么？考虑下面这段代码："
msgstr ""

#: ../../google/typescript/language.rst:500
msgid ""
"从读者的角度看，这段代码并没有什么问题： ``x`` 没有被初始化为 ``null`` "
"，并且在被访问之前也没有发生过任何变化。但是对编译器而言，它并不知道传给 ``.forEach()`` 的闭包 ``() => { "
"x.charAt(0); }`` 会被立即执行。因此，编译器有理由认为闭包有可能在之后的某处代码中被调用，而到那时 ``x`` 已经被设为 "
"``null`` 。于是，这里出现了一个编译错误。与之等价的 ``for-of`` 形式的迭代就不会有任何问题。"
msgstr ""

#: ../../google/typescript/language.rst:502
msgid ""
"读者可以在 `这里 "
"<https://www.typescriptlang.org/play?#code/DYUwLgBAHgXBDOYBOBLAdgcwD5oK7GAgF4IByAQwCMBjUgbgCgBtAXQDoAzAeyQFFzqACwAUwgJTEAfBADeDCNDZDySAIJhhABjGMAvjoYNQkAJ5xEqTDnyESFGvQbckEYdS5pEEAPoQuHCFYJOQUTJUEVdS0DXQYgA>`_"
" 对比这两个版本的代码。"
msgstr ""

#: ../../google/typescript/language.rst:504
msgid "在工程实践中，代码路径越复杂、越违背直觉，越容易在进行控制流分析时出现这类问题。"
msgstr ""

#: ../../google/typescript/language.rst:509
msgid "展开运算符"
msgstr ""

#: ../../google/typescript/language.rst:511
msgid ""
"在复制数组或对象时，展开运算符 ``[...foo]``\\ 、\\ ``{...bar}`` "
"是一个非常方便的语法。使用展开运算符时，对于同一个键，后出现的值会取代先出现的值。"
msgstr ""

#: ../../google/typescript/language.rst:535
msgid "在使用展开运算符时，被展开的值必须与被创建的值相匹配。也就是说，在创建对象时只能展开对象，在创建数组时只能展开可迭代类型。"
msgstr ""

#: ../../google/typescript/language.rst:537
msgid "禁止展开原始类型，包括 ``null`` 和 ``undefined`` 。"
msgstr ""

#: ../../google/typescript/language.rst:564
msgid "控制流语句 / 语句块"
msgstr ""

#: ../../google/typescript/language.rst:566
msgid "多行控制流语句必须使用大括号。"
msgstr ""

#: ../../google/typescript/language.rst:587
msgid "这条规则的例外时，能够写在同一行的 ``if`` 语句可以省略大括号。"
msgstr ""

#: ../../google/typescript/language.rst:597
msgid "``switch`` 语句"
msgstr ""

#: ../../google/typescript/language.rst:599
msgid "所有的 ``switch`` 语句都必须包含一个 ``default`` 分支，即使这个分支里没有任何代码。"
msgstr ""

#: ../../google/typescript/language.rst:612
msgid "非空语句组（ ``case ...`` ）不允许越过分支向下执行（编译器会进行检查）："
msgstr ""

#: ../../google/typescript/language.rst:625
msgid "空语句组可以这样做："
msgstr ""

#: ../../google/typescript/language.rst:641
msgid "相等性判断"
msgstr ""

#: ../../google/typescript/language.rst:643
msgid ""
"必须使用三等号（ ``===`` ）和对应的不等号（ ``!==`` ）。两等号会在比较的过程中进行类型转换，这非常容易导致难以理解的错误。并且在"
" JavaScript 虚拟机上，两等号的运行速度比三等号慢。参见 `JavaScript 相等表 "
"<https://dorey.github.io/JavaScript-Equality-Table/>`_ 。"
msgstr ""

#: ../../google/typescript/language.rst:659
msgid ""
"**例外**：和 ``null`` 字面量的比较可以使用 ``==`` 和 ``!=`` 运算符，这样能够同时覆盖 ``null`` 和 "
"``undefined`` 两种情况。"
msgstr ""

#: ../../google/typescript/language.rst:671
msgid "函数声明"
msgstr ""

#: ../../google/typescript/language.rst:673
msgid "使用 ``function foo() { ... }`` 的形式声明具名函数，包括嵌套在其它作用域中，例如其它函数内部的函数。"
msgstr ""

#: ../../google/typescript/language.rst:675
msgid ""
"不要使用将函数表达式赋值给局部变量的写法（例如 ``const x = function() {...};`` ）。TypeScript "
"本身已不允许重新绑定函数，所以在函数声明中使用 ``const`` 来阻止重写函数是没有必要的。"
msgstr ""

#: ../../google/typescript/language.rst:677
msgid "**例外**：如果函数需要访问外层作用域的 ``this`` ，则应当使用将箭头函数赋值给变量的形式代替函数声明的形式。"
msgstr ""

#: ../../google/typescript/language.rst:693
msgid ""
"请注意这里所说的函数声明（ ``function foo() {}`` ）和下面要讨论的函数表达式（ "
"``doSomethingWith(function() {});`` ）之间的区别。"
msgstr ""

#: ../../google/typescript/language.rst:695
msgid "顶层箭头函数可以用于显式地声明这一函数实现了一个接口。"
msgstr ""

#: ../../google/typescript/language.rst:708
msgid "函数表达式"
msgstr ""

#: ../../google/typescript/language.rst:713
msgid "在表达式中使用箭头函数"
msgstr ""

#: ../../google/typescript/language.rst:715
msgid "不要使用 ES6 之前使用 ``function`` 关键字定义函数表达式的版本。应当使用箭头函数。"
msgstr ""

#: ../../google/typescript/language.rst:727
msgid ""
"只有当函数需要动态地重新绑定 ``this`` 时，才能使用 ``function`` 关键字声明函数表达式，但是通常情况下代码中不应当重新绑定 "
"``this`` 。常规函数（相对于箭头函数和方法而言）不应当访问 ``this`` 。"
msgstr ""

#: ../../google/typescript/language.rst:732
msgid "表达式函数体 和 代码块函数体"
msgstr ""

#: ../../google/typescript/language.rst:734
msgid "使用箭头函数时，应当根据具体情况选择表达式或者代码块作为函数体。"
msgstr ""

#: ../../google/typescript/language.rst:755
msgid "只有在确实需要用到函数返回值的情况下才能使用表达式函数体。"
msgstr ""

#: ../../google/typescript/language.rst:779
msgid "重新绑定 ``this``"
msgstr ""

#: ../../google/typescript/language.rst:781
msgid ""
"不要在函数表达式中使用 ``this`` ，除非它们明确地被用于重新绑定 ``this`` "
"指针。大多数情况下，使用箭头函数或者显式指定函数参数都能够避免重新绑定 ``this`` 的需求。"
msgstr ""

#: ../../google/typescript/language.rst:806
msgid "使用箭头函数作为属性"
msgstr ""

#: ../../google/typescript/language.rst:808
msgid ""
"通常情况下，类不应该将任何属性初始化为箭头函数。箭头函数属性需要调用函数意识到被调用函数的 ``this`` 已经被绑定了，这让 ``this``"
" "
"的指向变得令人费解，也让对应的调用和引用在形式上看着似乎是不正确的，也就是说，需要额外的信息才能确认这样的使用方式是正确的。在调用实例方法时，必须使用箭头函数的形式（例如"
" ``const handler = (x) => { this.listener(x); };`` "
"）。此外，不允许持有或传递实例方法的引用（例如不要使用 ``const handler = this.listener; "
"handler(x);`` 的写法）。"
msgstr ""

#: ../../google/typescript/language.rst:812
msgid ""
"在一些特殊的情况下，例如需要将函数绑定到模板时，使用箭头函数作为属性是很有用的做法，同时还能令代码的可读性提高。因此，在这些情况下对于这条规则可视具体情况加以变通。此外，"
" :ref:`ts-event-handlers` 一节中有相关讨论。"
msgstr ""

#: ../../google/typescript/language.rst:859
msgid "事件句柄"
msgstr ""

#: ../../google/typescript/language.rst:861
msgid ""
"对于事件句柄，如果它不需要被卸载的话，可以使用箭头函数的形式，例如事件是由类自身发送的情况。如果句柄必须被卸载，则应当使用箭头函数属性，因为箭头函数属性能够自动正确地捕获"
" ``this`` 指针，并且能够提供一个用于卸载的稳定引用。"
msgstr ""

#: ../../google/typescript/language.rst:886
msgid "不要在注册事件句柄的表达式中使用 ``bind`` ，这会创建一个无法卸载的临时引用。"
msgstr ""

#: ../../google/typescript/language.rst:908
msgid "自动分号插入"
msgstr ""

#: ../../google/typescript/language.rst:910
msgid ""
"不要依赖自动分号插入（ASI），必须显式地使用分号结束每一个语句。这能够避免由于不正确的分号插入所导致的 Bug，也能够更好地兼容对 ASI "
"支持有限的工具（例如 clang-format）。"
msgstr ""

#: ../../google/typescript/language.rst:915
msgid "``@ts-ignore``"
msgstr ""

#: ../../google/typescript/language.rst:917
msgid ""
"不要使用 ``@ts-ignore`` "
"。表面上看，这是一个“解决”编译错误的简单方法，但实际上，编译错误往往是由其它更大的问题导致的，因此正确的做法是直接解决这些问题本身。"
msgstr ""

#: ../../google/typescript/language.rst:919
msgid ""
"举例来说，如果使用 ``@ts-ignore`` 关闭了一个类型错误，那么便很难推断其它相关代码最终会接收到何种类型。对于许多与类型相关的错误， "
":ref:`ts-any-type` 一节有一些关于如何正确使用 ``any`` 的有用的建议。"
msgstr ""

#: ../../google/typescript/language.rst:924
msgid "类型断言与非空断言"
msgstr ""

#: ../../google/typescript/language.rst:926
msgid ""
"类型断言（ ``x as SomeType`` ）和非空断言（ ``y!`` "
"）是不安全的。这两种语法只能够绕过编译器，而并不添加任何运行时断言检查，因此有可能导致程序在运行时崩溃。"
msgstr ""

#: ../../google/typescript/language.rst:928
msgid "因此，除非有明显或确切的理由，否则 *不应* 使用类型断言和非空断言。"
msgstr ""

#: ../../google/typescript/language.rst:937
msgid "如果希望对类型和非空条件进行断言，最好的做法是显式地编写运行时检查。"
msgstr ""

#: ../../google/typescript/language.rst:952
msgid "有时根据代码中的上下文可以确定某个断言必然是安全的。在这种情况下， *应当* 添加注释详细地解释为什么这一不安全的行为可以被接受："
msgstr ""

#: ../../google/typescript/language.rst:964
msgid "如果使用断言的理由很明显，注释就不是必需的。例如，生成的协议代码总是可空的，但有时根据上下文可以确认其中某些特定的由后端提供的字段必然不为空。在这些情况下应当根据具体场景加以判断和变通。"
msgstr ""

#: ../../google/typescript/language.rst:969
msgid "类型断言语法"
msgstr ""

#: ../../google/typescript/language.rst:971
msgid "类型断言必须使用 ``as`` 语法，不要使用尖括号语法，这样能强制保证在断言外必须使用括号。"
msgstr ""

#: ../../google/typescript/language.rst:987
msgid "类型断言和对象字面量"
msgstr ""

#: ../../google/typescript/language.rst:989
msgid ""
"使用类型标记（ ``: Foo`` ）而非类型断言（ ``as Foo`` "
"）标明对象字面量的类型。在日后对接口的字段类型进行修改时，前者能够帮助程序员发现 Bug。"
msgstr ""

#: ../../google/typescript/language.rst:1013
msgid "成员属性声明"
msgstr ""

#: ../../google/typescript/language.rst:1015
msgid "接口和类的声明必须使用 ``;`` 分隔每个成员声明。"
msgstr ""

#: ../../google/typescript/language.rst:1025
msgid "为了与类的写法保持一致，不要在接口中使用 ``,`` 分隔字段。"
msgstr ""

#: ../../google/typescript/language.rst:1035
msgid "然而，内联对象类型声明必须使用 ``,`` 作为分隔符。"
msgstr ""

#: ../../google/typescript/language.rst:1050
msgid "优化属性访问的兼容性"
msgstr ""

#: ../../google/typescript/language.rst:1052
msgid "不要混用方括号属性访问和句点属性访问两种形式。"
msgstr ""

#: ../../google/typescript/language.rst:1061
msgid "代码应当尽可能为日后的属性重命名需求进行优化，并且为所有程序外部的对象属性声明对应的字段。"
msgstr ""

#: ../../google/typescript/language.rst:1076
msgid "优化模块对象导入的兼容性"
msgstr ""

#: ../../google/typescript/language.rst:1078
msgid ""
"导入模块对象时应当直接访问对象上的属性，而不要传递对象本身的引用，以保证模块能够被分析和优化。也可以将导入的模块视作命名空间，参见 :ref"
":`ts-module-versus-destructuring-imports` 一节。"
msgstr ""

#: ../../google/typescript/language.rst:1099
msgid "例外情况"
msgstr ""

#: ../../google/typescript/language.rst:1101
msgid ""
"这里所提到的优化规则适用于所有的 Web "
"应用，但不需要强制应用于只运行在服务端的程序。不过，出于代码整洁性的考虑，这里仍然强烈建议声明所有的类型，并且避免混用两种属性访问的形式。"
msgstr ""

#: ../../google/typescript/language.rst:1106
msgid "枚举"
msgstr ""

#: ../../google/typescript/language.rst:1108
msgid ""
"对于枚举类型，必须使用 ``enum`` 关键字，但不要使用 ``const enum`` 。TypeScript 的枚举类型本身就是不可变的， "
"``const enum`` 的写法是另一种独立的语言特性，其目的是让枚举对 JavaScript 程序员透明。"
msgstr ""

#: ../../google/typescript/language.rst:1113
msgid "``debugger`` 语句"
msgstr ""

#: ../../google/typescript/language.rst:1115
msgid "不允许在生产环境代码中添加 ``debugger`` 语句。"
msgstr ""

#: ../../google/typescript/language.rst:1127
msgid "装饰器"
msgstr ""

#: ../../google/typescript/language.rst:1129
msgid "装饰器以 ``@`` 为前缀，例如 ``@MyDecorator`` 。"
msgstr ""

#: ../../google/typescript/language.rst:1131
msgid "不要定义新的装饰器，只使用框架中已定义的装饰器，例如："
msgstr ""

#: ../../google/typescript/language.rst:1133
msgid "Angular（例如 ``@Component`` 、 ``@NgModule`` 等等）"
msgstr ""

#: ../../google/typescript/language.rst:1134
msgid "Polymer（例如 ``@property`` 等等）"
msgstr ""

#: ../../google/typescript/language.rst:1138
msgid "通常情况下，应当避免使用装饰器。这是由于装饰器是一个实验性功能，仍然处于 TC39 委员会的提案阶段，且目前存在已知的无法被修复的 Bug。"
msgstr ""

#: ../../google/typescript/language.rst:1140
msgid "使用装饰器时，装饰器必须紧接被装饰的符号，中间不允许有空行。"
msgstr ""

